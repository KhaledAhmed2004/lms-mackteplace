import { model, Schema } from 'mongoose';
import {
  ITutorEarnings,
  TutorEarningsModel,
  PAYOUT_STATUS,
} from './tutorEarnings.interface';

// Earning Line Item Schema
const EarningLineItemSchema = new Schema(
  {
    sessionId: {
      type: Schema.Types.ObjectId,
      ref: 'Session',
      required: true,
    },
    studentName: {
      type: String,
      required: true,
    },
    subject: {
      type: String,
      required: true,
    },
    completedAt: {
      type: Date,
      required: true,
    },
    duration: {
      type: Number,
      required: true, // minutes
    },
    sessionPrice: {
      type: Number,
      required: true, // EUR (full price)
    },
    tutorEarning: {
      type: Number,
      required: true, // EUR (after commission)
    },
  },
  { _id: false }
);

const tutorEarningsSchema = new Schema<ITutorEarnings>(
  {
    tutorId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: [true, 'Tutor ID is required'],
    },
    payoutMonth: {
      type: Number,
      required: [true, 'Payout month is required'],
      min: 1,
      max: 12,
    },
    payoutYear: {
      type: Number,
      required: [true, 'Payout year is required'],
    },
    periodStart: {
      type: Date,
      required: [true, 'Period start is required'],
    },
    periodEnd: {
      type: Date,
      required: [true, 'Period end is required'],
    },
    lineItems: {
      type: [EarningLineItemSchema],
      default: [],
    },
    totalSessions: {
      type: Number,
      default: 0,
    },
    totalHours: {
      type: Number,
      default: 0,
    },
    grossEarnings: {
      type: Number,
      required: [true, 'Gross earnings is required'],
      default: 0,
    },
    platformCommission: {
      type: Number,
      required: [true, 'Platform commission is required'],
      default: 0,
    },
    commissionRate: {
      type: Number,
      required: [true, 'Commission rate is required'],
      default: 0, // 0% - No commission, tutor gets 100%
    },
    netEarnings: {
      type: Number,
      required: [true, 'Net earnings is required'],
      default: 0,
    },
    status: {
      type: String,
      enum: Object.values(PAYOUT_STATUS),
      default: PAYOUT_STATUS.PENDING,
    },
    stripeTransferId: {
      type: String,
    },
    stripePayoutId: {
      type: String,
    },
    paidAt: {
      type: Date,
    },
    paymentMethod: {
      type: String,
    },
    notes: {
      type: String,
      trim: true,
    },
    failureReason: {
      type: String,
      trim: true,
    },
    payoutReference: {
      type: String,
      required: [true, 'Payout reference is required'],
      unique: true,
    },
  },
  { timestamps: true }
);

// Indexes
tutorEarningsSchema.index({ tutorId: 1, payoutYear: -1, payoutMonth: -1 });
tutorEarningsSchema.index({ status: 1 });
tutorEarningsSchema.index({ payoutReference: 1 });
tutorEarningsSchema.index({ stripeTransferId: 1 });

// Compound unique index to prevent duplicate payouts
tutorEarningsSchema.index(
  { tutorId: 1, payoutYear: 1, payoutMonth: 1 },
  { unique: true }
);

// Pre-save: Generate payout reference
tutorEarningsSchema.pre('save', function (next) {
  if (this.isNew && !this.payoutReference) {
    const year = this.payoutYear.toString().slice(-2); // Last 2 digits
    const month = this.payoutMonth.toString().padStart(2, '0');
    const random = Math.random().toString(36).substring(2, 8).toUpperCase();
    this.payoutReference = `PAYOUT-${year}${month}-${random}`;
  }
  next();
});

// Pre-save: Calculate earnings
tutorEarningsSchema.pre('save', function (next) {
  if (this.lineItems && this.lineItems.length > 0) {
    this.totalSessions = this.lineItems.length;
    this.totalHours = this.lineItems.reduce(
      (sum, item) => sum + item.duration / 60,
      0
    );
    this.grossEarnings = this.lineItems.reduce(
      (sum, item) => sum + item.sessionPrice,
      0
    );
    this.platformCommission = this.grossEarnings * this.commissionRate;
    this.netEarnings = this.grossEarnings - this.platformCommission;
  }
  next();
});

export const TutorEarnings = model<ITutorEarnings, TutorEarningsModel>(
  'TutorEarnings',
  tutorEarningsSchema
);
